---
layout: posts
title: CS231n Assignment2
date: 2018-12-03 00:35:55
tags: [cs231n, assignment]
---



听完了整体的CNN的框架和常用的调参技巧后，开始着手做assignment2

<!--more-->

以下记录做题时遇到的问题



## FullyConnectedNets.ipynb

这个ipynb主要是将assignment1中的two_layer_net中实现的功能用一种模块化的形式去实现更复杂（多层网络）的结构

### 数据预处理

首先要运行一个setup.py文件，目的是将某些用C写的东西编译出来，主要是涉及一个imcool的算法，去减少卷积的算法复杂度（还没有细看，就先跑一下）

```python
# As usual, a bit of setup
from __future__ import print_function	##__future__兼容此版本没有的库
import time
import numpy as np
import matplotlib.pyplot as plt
from cs231n.classifiers.fc_net import *
from cs231n.data_utils import get_CIFAR10_data
from cs231n.gradient_check import eval_numerical_gradient, eval_numerical_gradient_array
from cs231n.solver import Solver

# ipython里的magic function，用来内嵌绘图，同时可以省略plt.show()
%matplotlib inline	

# 默认的像素：[6.0,4.0]，分辨率为100，图片尺寸为 600&400
# 指定dpi=200，图片尺寸为 1200*800
# 指定dpi=300，图片尺寸为 1800*1200
# 设置figsize可以在不改变分辨率情况下改变比例
plt.rcParams['figure.figsize'] = (10.0, 8.0) 
plt.rcParams['image.interpolation'] = 'nearest' # 设置最近邻插值
plt.rcParams['image.cmap'] = 'gray' # 设置灰度输出

# 在ipython（jupyter基于ipython）里已经import过的模块修改后需要重新reload的部分自动reload
%load_ext autoreload
%autoreload 2

def rel_error(x, y):
  """ returns relative error """
  return np.max(np.abs(x - y) / (np.maximum(1e-8, np.abs(x) + np.abs(y))))

data = get_CIFAR10_data()
for k, v in list(data.items()):
  print(('%s: ' % k, v.shape))
```

### Affine layer: foward

完成cs231n/layers.py 里的affine_forward 方程

1. tuple类型 不熟悉——用[]取tuple的element
2. 不同维度的矩阵间操作不熟悉——如何扩充还是要找个机会搞清楚

```python

def affine_forward(x, w, b):
"""
Inputs:
- x: A numpy array containing input data, of shape (N, d_1, ..., d_k)
- w: A numpy array of weights, of shape (D, M)
- b: A numpy array of biases, of shape (M,)

Returns a tuple of:
- out: output, of shape (N, M)
- cache: (x, w, b)
"""
out = None
###########################################################################
# TODO: Implement the affine forward pass. Store the result in out. You   #
# will need to reshape the input into rows.                               #
###########################################################################
#print(type(x.shape))   # x.shape的类型是tuple
N = x.shape[0]          # 取tuple类型数组用[]
x = x.reshape(N, -1)    # (N,D)
out = x.dot(w)          # (N,M）
out += b                # (N,M），自动扩充b的维度以适应out

###########################################################################
#                             END OF YOUR CODE                            #
###########################################################################
cache = (x, w, b)
return out, cache
```
在ipynb中测试forward的方程

1. tuple前面加*号，可以变成可变参数传进去，这个是链接，还是没怎么懂https://zhidao.baidu.com/question/369701615352347164.html，同时还要搞清楚和reshape的联合是怎么做的
2. np.prod()：默认计算所有element的乘积，可定义按某个轴计算
3. Np.linspace(): 生成等差数列，默认间隔50，num项自定义间隔

```python
# Test the affine_forward function

num_inputs = 2
input_shape = (4, 5, 6)
output_dim = 3

#Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
#print(*input_shape)

input_size = num_inputs * np.prod(input_shape)# np.prod()计算数组元素乘积
weight_size = output_dim * np.prod(input_shape)

# linspace函数默认生成等间隔(50)数列,点明num时以num作为间隔
x = np.linspace(-0.1, 0.5, num=input_size).reshape(num_inputs, *input_shape)
w = np.linspace(-0.2, 0.3, num=weight_size).reshape(np.prod(input_shape), output_dim)
b = np.linspace(-0.3, 0.1, num=output_dim)

out, _ = affine_forward(x, w, b)
correct_out = np.array([[ 1.49834967,  1.70660132,  1.91485297],
                        [ 3.25553199,  3.5141327,   3.77273342]])

# Compare your output with ours. The error should be around e-9 or less.
print('Testing affine_forward function:')
print('difference: ', rel_error(out, correct_out))
```

